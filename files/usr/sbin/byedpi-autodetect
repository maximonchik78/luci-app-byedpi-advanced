#!/bin/bash

# Автоподбор параметров для ByeDPI
# Версия: 2.0
# Автор: maximonchik78

CONFIG="/etc/config/byedpi"
LOG="/tmp/byedpi-autodetect.log"
PIDFILE="/var/run/byedpi-autodetect.pid"
LOCKFILE="/var/lock/byedpi-autodetect.lock"

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Методы ByeByeDPI
declare -A METHODS=(
    [1]="--ttl"
    [2]="--wrong-chksum"
    [3]="--wrong-seq"
    [4]="--frag"
    [5]="--tamper-tcpack"
    [6]="--tamper-tcpchksum"
    [0]="--auto"
)

# Порты для тестирования
PORTS=("443" "80" "8080" "53")

# Тестовые URL
TEST_URLS=(
    "https://rutracker.org"
    "https://vk.com"
    "https://telegram.org"
    "https://twitter.com"
    "https://github.com"
)

# Функция логирования
log() {
    local message="$1"
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $message" | tee -a "$LOG"
    logger -t "byedpi-autodetect" "$message"
}

# Проверка зависимостей
check_dependencies() {
    local missing=()
    
    for cmd in curl wget pgrep kill uci; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing+=("$cmd")
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        log "${RED}Отсутствуют зависимости: ${missing[*]}${NC}"
        return 1
    fi
    
    if [ ! -x "/usr/sbin/byedpi" ]; then
        log "${RED}ByeDPI не найден или не исполняемый${NC}"
        return 1
    fi
    
    return 0
}

# Блокировка
acquire_lock() {
    exec 200>"$LOCKFILE"
    if ! flock -n 200; then
        log "${YELLOW}Другой процесс автоподбора уже запущен${NC}"
        return 1
    fi
    echo $$ > "$PIDFILE"
    return 0
}

# Освобождение блокировки
release_lock() {
    rm -f "$PIDFILE"
    flock -u 200
    rm -f "$LOCKFILE"
}

# Остановка ByeDPI
stop_byedpi() {
    if pgrep -f "/usr/sbin/byedpi" >/dev/null; then
        log "Останавливаю ByeDPI..."
        pkill -f "/usr/sbin/byedpi"
        sleep 2
        pkill -9 -f "/usr/sbin/byedpi" 2>/dev/null || true
    fi
}

# Проверка соединения
test_connection() {
    local url="$1"
    local timeout="${2:-10}"
    
    if curl -s -I --connect-timeout "$timeout" "$url" 2>/dev/null | grep -q -E "HTTP.*200|HTTP.*30[0-9]"; then
        return 0
    fi
    
    if wget --spider --timeout="$timeout" -t 1 "$url" >/dev/null 2>&1; then
        return 0
    fi
    
    return 1
}

# Тестирование метода обхода
test_bypass_method() {
    local method="$1"
    local port="$2"
    local test_url="$3"
    
    log "Тестирование: метод=$method, порт=$port, URL=$test_url"
    
    local cmd="/usr/sbin/byedpi"
    
    if [ "$method" != "0" ] && [ -n "${METHODS[$method]}" ]; then
        cmd="$cmd ${METHODS[$method]}"
    else
        cmd="$cmd --auto"
    fi
    
    cmd="$cmd -p $port --daemon"
    
    eval "$cmd" >/dev/null 2>&1 &
    local pid=$!
    
    sleep 3
    
    if ! ps -p "$pid" >/dev/null 2>&1; then
        log "${RED}Ошибка запуска ByeDPI с параметрами: method=$method, port=$port${NC}"
        return 1
    fi
    
    local success=0
    for i in {1..3}; do
        if test_connection "$test_url" 5; then
            success=1
            break
        fi
        sleep 2
    done
    
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
    
    if [ $success -eq 1 ]; then
        log "${GREEN}✓ Успех: метод=$method, порт=$port${NC}"
        return 0
    else
        log "${RED}✗ Не удалось: метод=$method, порт=$port${NC}"
        return 1
    fi
}

# Обнаружение лучшего метода
detect_best_method() {
    local best_method="0"
    local best_port="443"
    local found=0
    
    log "Начинаю сканирование методов обхода DPI..."
    
    local dpi_detected=0
    for url in "${TEST_URLS[@]}"; do
        if ! test_connection "$url" 10; then
            log "Обнаружена блокировка: $url"
            dpi_detected=1
            break
        fi
    done
    
    if [ $dpi_detected -eq 0 ]; then
        log "${GREEN}DPI блокировки не обнаружены${NC}"
        echo "0:443"
        return 0
    fi
    
    for port in "${PORTS[@]}"; do
        for method in 0 1 2 3 4 5 6; do
            for test_url in "${TEST_URLS[@]}"; do
                if ! test_connection "$test_url" 5; then
                    if test_bypass_method "$method" "$port" "$test_url"; then
                        best_method="$method"
                        best_port="$port"
                        found=1
                        break 3
                    fi
                fi
            done
        done
    done
    
    if [ $found -eq 1 ]; then
        log "${GREEN}Найден оптимальный метод: $best_method, порт: $best_port${NC}"
        echo "$best_method:$best_port"
        return 0
    else
        log "${RED}Не удалось найти рабочий метод обхода DPI${NC}"
        return 1
    fi
}

# Обновление конфигурации
update_config() {
    local method="$1"
    local port="$2"
    
    log "Обновляю конфигурацию: method=$method, port=$port"
    
    uci set byedpi.@settings[0].mode="$method"
    uci set byedpi.@settings[0].port="$port"
    uci commit byedpi
    
    log "Конфигурация обновлена"
}

# Основная функция
main() {
    log "=== Запуск автоподбора параметров ByeDPI ==="
    
    if ! check_dependencies; then
        exit 1
    fi
    
    if ! acquire_lock; then
        exit 1
    fi
    
    stop_byedpi
    
    local result
    if result=$(detect_best_method); then
        IFS=':' read -r best_method best_port <<< "$result"
        
        update_config "$best_method" "$best_port"
        
        if [ -x "/etc/init.d/byedpi" ]; then
            /etc/init.d/byedpi restart
            log "${GREEN}ByeDPI перезапущен с новыми параметрами${NC}"
        fi
        
        log "${GREEN}Автоподбор успешно завершен!${NC}"
        log "Результат: Метод=$best_method, Порт=$best_port"
    else
        log "${YELLOW}Использую настройки по умолчанию${NC}"
        update_config "0" "443"
        if [ -x "/etc/init.d/byedpi" ]; then
            /etc/init.d/byedpi restart
        fi
    fi
    
    release_lock
    
    log "=== Автоподбор завершен ==="
}

# Обработка сигналов
trap 'log "Прерывание..."; release_lock; exit 1' INT TERM

# Запуск
main "$@"
